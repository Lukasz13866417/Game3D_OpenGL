# OpenGL 3D Game From Scratch
## Overview
### Note: This project uses **my own** [custom API for efficient, terrain generation](https://github.com/Lukasz13866417/SymbolicGrid):
As a challenge, a year ago I used the Android Canvas API (which is 2D) to develop a full 3D Android game with Java. This required me to build all 3D graphics from the ground up. This involved lots of tiny optimizations and tricks to display proper 3D graphics, (cull faces, objects, modify Painter's algorithm, finding it's special cases), since this API is extremely slow. However, the severe limitations of this API started holding me back. I rewrote this game in **OpenGL**. Below is an image showing one of the versions of my game.
![421111466-8c90c4d3-9463-4554-817c-b5847766ecd8_enhanced](https://github.com/user-attachments/assets/2b78fd37-cfe1-4630-b902-ea5328005814)
## Project structure 
The project is divided into two most important packages: ```game``` and ```rendering```. <br>
The latter is a clean encapsulation of the OpenGL rendering pipeline, with self-explainatory classes like ```Camera```, ```Object3D```. 
The former is where all the game logic is defined (how the world is structured, the flow of the game, player), as well as the most important package: ```terrain```. <br>This is a **powerful API** that I developed to create a terrain composed of tiles (that form the landscape) and addons (like spikes, potions etc). The user can generate the terrain by creating subclasses of the ```TerrainStructure``` class. There, they get control over the creation of tiles, as well as the placing of addons. <br>Addons are placed on a grid. This specific part of the game required me to make a whole another project that handles randomized 2D grid queries with maximum efficiency (see my repo linked at the top of the README). Another crucial step was *lazy terrain generation*. This is what made it possible to generate terrain *on the fly*. The user (of the terrain API) creates some terrain structures, which are "compiled" into commands, which are *later* "interpreted". This was a real challenge, because the **terrain structures can have child structures**, forcing me to use even more data structures. <br>All this would be impossible if I hadn't used preallocation. Without this technique, the massive number of heap allocations and the Garbage Collector would destroy the performance, and the benefits of the **optimal time complexity** in my data structures would be invisible.
## Motivations
This whole project was the beginning of my process of learning 3D graphics. I **figured out on my own** how 3D points are projected onto a screen, how shapes are rasterized and how depth buffer values are computed. I studied algorithms used in 3D rendering and game, like the Möller–Trumbore ray-plane intersection algorithm (that I used for collision detection). After writing my [own hardware renderer](https://github.com/Lukasz13866417/GPU_SDL_Drawing), I decided to focus more on *research* rather than *development*. I learned OpenGL and some principles of game development and started incorporating my knowledge into this project.
